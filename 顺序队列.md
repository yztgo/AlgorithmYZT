# 队列结构
## 双端队列 ArrayDeque Linkedlist
/**
  
  依据原始数据 or 每一步都需要对数据进行修改 维护一个有顺序【进入先后顺序（poll offer) 下标顺序(if peek 滑动窗口大小 和当前index下标比较是否需要出队poll） 大小顺序（while peekLast peek根据某一方向的大小关系选择是否 poll pollLast) 最后addLast add当前元素 的队列结构 有的时候还需要改变原始数组中的元素 
 * 注意：是三种顺序中的组合 比如说单调栈 多个栈 滑动窗口最大值等等
  
*/

## 优先队列 PriorityQueue
/**

  按照comparator比较器维护一个指定比较对象某一属性或者多个属性的数据结构 一般是出队poll 和 进队add 某一个元素 （该元素是该数据结构中具有“最”性质的元素） 利用堆的性质在每一次添加和删除的时候都会进行shiftDown的下沉操作
  * 注意：这种操作仅仅会发生在元素的出队和进队时机 如果队列中存储的是某一个对象 对象的属性是comparator比较的对象 元素的属性发生变化之后 队列中元素之间的顺序是不会发生变化的
  * 所以我们通常不会去更新队列中的元素 而是直接删除该元素 重新添加新的元素 （这里考虑到真实场景 可以使用延时删除机制 使用一个HashMap<要删除的对象 ， count> 进行记录）
    
*/


****************************************************** 单调队列优化dp ***************************************************/
* [跳跃游戏](https://leetcode.cn/problems/jump-game-vi/description/)
* 队列中存储的是元素的下标 同时维护下标顺序（从左到右递增） 和 下标对应元素的大小顺序（从左到右递减）
*         LinkedList<Integer> que = new LinkedList(){{add(0);}};
          for(int i = 0 ; i < nums.length ; i++){
            int num = nums[i];
            // 检查是否还在滑动窗口内
            if(que.peek() + k < i) que.poll();
            int cur = nums[que.peek()];
            int updataNum = num + cur;
            nums[i] = updataNum;
            while(!que.isEmpty() && nums[que.peekLast()] < updataNum){
              que.pollLast();
            }
            que.add(i);
          }
          return nums[nums.length - 1]; 

