# 队列结构
## 双端队列 ArrayDeque Linkedlist
/**
  
  依据原始数据 or 每一步都需要对数据进行修改 维护一个有顺序【进入先后顺序（poll offer) 下标顺序(if peek 滑动窗口大小 和当前index下标比较是否需要出队poll） 大小顺序（while peekLast peek根据某一方向的大小关系选择是否 poll pollLast) 最后addLast add当前元素 的队列结构 有的时候还需要改变原始数组中的元素 
 * 注意：是三种顺序中的组合 比如说单调栈 多个栈 滑动窗口最大值等等
  
*/

## 优先队列 PriorityQueue
/**

  按照comparator比较器维护一个指定比较对象某一属性或者多个属性的数据结构 一般是出队poll 和 进队add 某一个元素 （该元素是该数据结构中具有“最”性质的元素） 利用堆的性质在每一次添加和删除的时候都会进行shiftDown的下沉操作
  * 注意：这种操作仅仅会发生在元素的出队和进队时机 如果队列中存储的是某一个对象 对象的属性是comparator比较的对象 元素的属性发生变化之后 队列中元素之间的顺序是不会发生变化的
  * 所以我们通常不会去更新队列中的元素 而是直接删除该元素 重新添加新的元素 （这里考虑到真实场景 可以使用延时删除机制 使用一个HashMap<要删除的对象 ， count> 进行记录）
    
*/


****************************************************** 单调队列优化dp ***************************************************/
* [跳跃游戏](https://leetcode.cn/problems/jump-game-vi/description/)
* 队列中存储的是元素的下标 同时维护下标顺序（从左到右递增） 和 下标对应元素的大小顺序（从左到右递减）
*         LinkedList<Integer> que = new LinkedList(){{add(0);}};
          for(int i = 0 ; i < nums.length ; i++){
            int num = nums[i];
            // 检查是否还在滑动窗口内
            if(que.peek() + k < i) que.poll();
            int cur = nums[que.peek()];
            int updataNum = num + cur;
            nums[i] = updataNum;
            while(!que.isEmpty() && nums[que.peekLast()] < updataNum){
              que.pollLast();
            }
            que.add(i);
          }
          return nums[nums.length - 1]; 


## 优先队列 PriorityQueue
/**

  模拟题：
  * 单堆模拟[会议室II]  
  * 双堆模拟[会议室III]
    
*/

****************************************************** 会议室III ***************************************************/
* 给定一组会议的开会时间，和n间会议室，使得这些会议能够进行（即时间端相交的两个会议不可能在同一间会议室里面进行，并且若存在多个会议空闲的情况，优先使用下标较小的会议室，如果会议室满了， 则必须要等待），要求你记录具体安排，即安排的会议室，每件会议室具体的会议安排，包括会议下标，会议时间。
* [会议室III](https://leetcode.cn/problems/meeting-rooms-iii/description/?envType=daily-question&envId=2026-01-09)
*      Arrays.sort(meetings , (a , b) -> a[0] - b[0]);
       PriorityQue<Integer> idQue = new PriorityQue();
       PriorityQue<int[]> usingQue = new PriorityQue<>((a , b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); //int[]{结束时间，index}
       List<int[]>[] cnt = new ArrayList[n];
       Arrays.setAll(cnt , _ -> new ArrayList());
       for(int[] i : meetings){
         int startTime = i[0] , endTime = i[1];
         while(!usingQue.isEmpty() && usingQue.peek() <= startTime){
             idQue.add(usingQue.poll()[1]);
         }
         if(!idQue.isEmpty()){
           int index = idQue.poll();
           usingQue.add(new int[]{endTime , index};
           cnt.get(int).add(new int[]{index , startTime , endTime)};
         }else{
           // 需要等待
           int[] cur = usingQue.poll();
           endTime = cur[0] + (endTime - startTime);
           cnt.get(cur[1]).add(new int[]{cur[1] , cur[0] , endTime});
           cur[0] = endTime;
         }
       } 

****************************************************** 会议室II ***************************************************/
* 给定一组会议的开会时间段，要求你安排n间会议室使得这些会议能够进行（即满足在同一时间段的所有会议都可以进行的最小n)
*       Arrays.sort(meetings , (a , b) -> a[0] - b[0]); // 按照会议开始时间进行排序
        PriorityQue<int[]> usingQue = new PriorityQue<>((a , b) -> a[0] == b[0] ? a[0] - b[0] : a[1] - b[1]); // 会议结束时间 ， 会议室下标
        PriorityQue<Integer> idQue =  new PriorityQue();
        int index = 0;
        for(int[] i : meetings){
          int startTime = i[0] , endTime = i[1];
          while(!usingQue.isEmpty() && usingQue.peek()[0] <= startTime){
            idQue.add(usingQue.poll()[1]);
          }
          if(idQue.isEmpty()){
            idQeu.add(index);
            index++;
          }
          int usingIndex = idQue.poll();
          usingQue.add(new int[]{endTime , usingIndex);
          cnt.get(usingIndex).add(new int[]{usingIndex , startTime , endTime});

<img width="831" height="321" alt="image" src="https://github.com/user-attachments/assets/bfe3edb1-5283-4545-9a46-a2476542b94d" />


****************************************************** 接雨水——单边结构，顺序寻找 ***************************************************/
* 给定若干根柱子 由于柱子高低不同构成一些凹槽 要你求出下雨天这些凹槽可以接多少水
*       for(int i = 0 ; i < height.length ; i++){
            while(!que.isEmpty() && height[que.peek() ] <= height[i]){
                int buttonIndex = que.pop();
                if(!que.isEmpty()){
                    int left = que.peek();
                    int heights = Math.min(height[i] , height[left]);
                    ans += (i - left - 1) * (heights - height[buttonIndex]);
                }
                que.push(i);           
            
       }


<img width="522" height="242" alt="image" src="https://github.com/user-attachments/assets/f8665821-0de7-4480-b4ee-5eb54e84a2c3" />

****************************************************** [柱状图中的最大矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/submissions/690597231/) ***************************************************/
* 给定若干根柱子 要你找出其中的最大矩形 寻找左右两边第一个比他小的柱形对应的下标[每日温度](https://leetcode.cn/problems/iIQa4I/) 注意和优先队列区分，
* 请你将每日温度转换为寻找第一个小于当前温度的下标（匿名内部类 优先队列中存储的是温度下标 但是比较器中比较的是下标对应的温度 匿名类是一种内部类，不能访问非 final 变量或 effectively final 变量，也无法按照 JLS 8.1.3 的规定在其封闭作用域内的变量进行修改。）， 计算以当前柱形为高的矩形的最大面积 int curS = ( rightMin[i] - 1 - (leftMin[i] + 1) + 1 ) * heigth[i]; 底乘以高
*       ArrayDeque<Integer> leftQue = new ArrayDeque() , rightQue = new ArrayDeque();
        int[] leftMin = new int[n] , rightMin = new int[n];
        for(int i = 0 ; i < n ; i++){
          int left = n - i - 1 , right = i;
          while(!que.isEmpty() && height[leftQue.peek()] > height[left]){
              leftMin[leftQue.pop()] = left;
          }
          leftQue.push(left);
          while(!que.isEmpty() && height[rightQue.peek()] > height[right]){
              rightMin[rightQue.pop()] = right;
          }
          rightQue.push(right);
        }
        while(!leftQue.isEmpty()){ leftMin[leftQue.pop()] = -1;}
        while(!rightQue.isEmpty()){ rightMin[rightQue.pop()] = n;}
        // 进行计算
        for(int i = 0 ; i < n ; i++){
          ans = Math.max(ans , （(rightMin[i] - 1) - (leftMin[i] + 1) + 1 ) * height[i]);
        }
  

          
          
          
