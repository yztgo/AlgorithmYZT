# 二分法 求方程的解（最小或最大满足“方程”的解）
/**
  * 递增结构：递增解对应的递增空间
  * 边界判定：解对应的”方程“是否成立

  * 首先判断二分对象倾向于那一边会使得问题成立，也就是在区间的左边还是右边
  * 然后根据题目要求判断是找第一个还是最后一个
  * 写出check()函数 然后判断check():true 是移动left指针还是right指针
  * 最后判断返回值

*/

************************************** 二分查找 *******************************************
* 查找数组中第一个小于(最后一个等于X - 1)/等于X的元素下标
* 查找数组中最后一个大于(第一个等于x + 1)/等于X的元素下标
*      Arrays.sort(nums);
       int left = 0 , right = nums.length - 1;
       while(left <= right){
         int midle = left + (right - left) / 2;
         // 第一个等于x的元素下标
         if(nums[midle] < target) left = midle + 1;
         else right = midle - 1;

       }
       return nums[left] == target ? left (第一个等于目标值的元素下标）: left - 1(第一个小于目标值的元素下标）;



************************************** 最大最小边界 *******************************************      
* 边界两边所属的区域 check()函数对应left right的判断 check(True) left = midle + 1 那么left之后的都是能够满足true的元素 但是此时的left是否也是在true的范围之内呢
* 求最小，也就是区间中第一个能够满足的元素对应的下标 check(True -> left ：< ; right : >= ) 也就是在left的右边都存在和指定值相等的元素 ， 需要靠right慢慢的进行内缩，首先right和left都是要缩小到符合条件的区间
* 求最大，也就是区间中最后一个能够满足的元素对应的下标，可以将x + 1进行转换为寻找区间中第一个满足的元素的下标减1 但是也可以根据划分区间的性质进行求解，仅仅改变check()中的判定条件和最终的返回值
* [求数组中target元素第一次出现和最后一次出现的位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
*     Arrays.sort(nums);
      int left = 0 , right = nums.length - 1;
      while(left <= right){
        int midle = left + (right - left) / 2;
        if(nums[midle] < target) left = midel + 1;
        else right = midel - 1;
      }
      return left;

      left = 0 , right = nums.length - 1;
      while(left <= right){
        int midel = left + (right - left) / 2;
        if(nums[midel] <= target) left = midel + 1;
        else right = midel - 1;
      }
      return left - 1;
    



* check(midel) 将[left , right]划分成两个区间 ， 若是递增（越往右条件越成立），寻找第一个则需要移动right（在check(midel) = true) ，因为right指针不一定包含正确数的，但是其左边一定包含，返回的值就是left ； 若是寻找最后一个移动left（将指针移出当前可能的正确答案的区间，保证left的左边都是成立的） ，（在check(midel) = true) ，因为left指针不一定包含正确数，但是返回的值就是left - 1；
* 1[爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/description/)（吃的速度越快，则越可能满足条件，所以right（靠近区间的右边总是会成立的），所以right指针右边都是满足的，但是right本身不满足，终止条件是（left == right) 所以停止的时候是left = right + 1,返回的left就是答案）
* 2[孩子可以分得的最大饼干数](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/description/)（每人分得的饼干越多，那么能够分的人就越少，所以left（靠近区间的左边总是会成立的），所以left指针的左边都是满足的，但是left本身不满足，终止条件是（left == right) 所以停止的时候是left = right + 1,返回的left - 1就是答案）
* 注意：实际上查找数是比一般实际的二分问题要困难的，在现实问题中，可以预先知道问题是否存在答案，而我们指定的区间中是一定有一个答案的，但是查找数却不一定
* 3[装袋的开销最小](https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/description/)（饼干数量（开销）越大，所需要划分的次数就越少，越能满足条件，所以越靠近区间的左边总会成立，也就是最后一个满足条件的二分，同2)

* 极小化分组后的max(group[i]) - min(group[i]) i = 0 …… k 和 极小化 max(gourp[i])等价 [华为10.10分布式计算任务调度](https://www.nowcoder.com/exam/test/94482159/submission?examPageSource=Search&pid=64590300)
