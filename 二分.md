# 二分法 求方程的解（最小或最大满足“方程”的解）
/**
  * 递增结构：递增解对应的递增空间
  * 边界判定：解对应的”方程“是否成立

*/

************************************** 二分查找 *******************************************
* 查找数组中第一个小于(最后一个等于X - 1)/等于X的元素下标
* 查找数组中最后一个大于(第一个等于x + 1)/等于X的元素下标
*      Arrays.sort(nums);
       int left = 0 , right = nums.length - 1;
       while(left <= right){
         int midle = left + (right - left) / 2;
         // 第一个等于x的元素下标
         if(nums[midle] < target) left = midle + 1;
         else right = midle - 1;

       }
       return nums[left] == target ? left (第一个等于目标值的元素下标）: left - 1(第一个小于目标值的元素下标）;



************************************** 最大最小边界 *******************************************      
* 边界两边所属的区域 check()函数对应left right的判断 check(True) left = midle + 1 那么left之后的都是能够满足true的元素 但是此时的left是否也是在true的范围之内呢
* 求最小，也就是区间中第一个能够满足的元素对应的下标 check(True -> left ：< ; right : >= ) 也就是在left的右边都存在和指定值相等的元素 ， 需要靠right慢慢的进行内缩，首先right和left都是要缩小到符合条件的区间
* 求最大，也就是区间中最后一个能够满足的元素对应的下标 进行转换即可 符合条件加1
* check(midel) 将[left , right]划分成两个区间 ， 若是递增（越往右条件越成立），寻找第一个则需要移动right（在check(midel) = true) ，因为right指针是包含正确数的，但是返回的值还是需要看题目的问题
* 爱吃香蕉的珂珂（吃的速度越快，则越可能满足条件，所以right（靠近区间的右边总是会成立的），所以right指针右边都是满足的，但是right本身不满足，终止条件是（left == right) 所以停止的时候是left = right + 1,返回的left就是答案）
* 孩子可以分得的最大饼干数（没人分得的饼干越多，那么能够分的人就越少，所以left（靠近区间的左边总是会成立的），所以left指针的左边都是满足的，但是left本身不满足，终止条件是（left == right) 所以停止的时候是left = right + 1,返回的left - 1就是答案）
