# 二分法 求方程的解（最小或最大满足“方程”的解）
/**
  * 递增结构：递增解对应的递增空间
  * 边界判定：解对应的”方程“是否成立

*/

************************************** 二分查找 *******************************************
* 查找数组中第一个小于(最后一个等于X - 1)/等于X的元素下标
* 查找数组中最后一个大于(第一个等于x + 1)/等于X的元素下标
*      Arrays.sort(nums);
       int left = 0 , right = nums.length - 1;
       while(left <= right){
         int midle = left + (right - left) / 2;
         // 第一个等于x的元素下标
         if(nums[midle] < target) left = midle + 1;
         else right = midle - 1;

       }
       return nums[left] == target ? left (第一个等于目标值的元素下标）: left - 1(第一个小于目标值的元素下标）;



************************************** 最大最小边界 *******************************************      
* 边界两边所属的区域 check()函数对应left right的判断 check(True) left = midle + 1 那么left之后的都是能够满足true的元素 但是此时的left是否也是在true的范围之内呢
* 求最小，也就是区间中第一个能够满足的元素对应的下标 check(True -> left ：< ; right : >= ) 也就是在left的右边都存在和指定值相等的元素 ， 需要靠right慢慢的进行内缩，首先right和left都是要缩小到符合条件的区间
* 求最大，也就是区间中最后一个能够满足的元素对应的下标 进行转换即可 符合条件加1
  
