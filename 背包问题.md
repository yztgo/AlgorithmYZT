  /** 标准的0-1背包问题
  *    容量大小为m的背包  存在n种物品 物品的重量记作wi 价值记作vi (i = 1 , …… , n) 每种物品数量都是1
  *    求背包中可以装入物品的最大价值和是多少？
      
  */

  /************************************** dfs剪枝优化 **************************************/
  *   中心思想 选或不选
  *     int dfs(int index , int money , int[] costs , int[] values , int[][] memo){
  *       if(index == costs.length) return 0 ;
  *       if(memo[index][money] == -1){
  *         int cost = costs[index] , value = values[index];
  *         if(money >= cost){
  *           memo[index][money] = Math.max(dfs(index + 1 , money , costs , values , memo) , dfs(index + 1 , meney - cost , values , memo) + value);
  *         }else memo[index][money] = dfs(index + 1 , money , costs , values , memo);
  *       }
  *     return memo[index][money];
  *     }    
  *         
  *                    
  *************************************** 递归 -> 递推 **************************************/
  * // 二维数组 dp[num + 1][money + 1];
  *     for(int i = 1 ; i < num ; i++){
  *      int cost = costs[i];
  *      for(int j = 1 ; j <= money ; j++){
  *        dp[i][j] = dp[i - 1][j];
  *        if(j >= cost){
  *           int value = values[i];
  *           dp[i][j] = Math.max(dp[i][j] , dp[i - 1][j - cost] + value);
  *        }
  *      }
  *     }
  *     return dp[num][moeny];
  *    
  * // 一维滚动数组 dp[i] 只和 dp[i - 1] 相关  每次仅仅改变j 关键是j的变化 倒序遍历
  *     for(int i = 1 ; i < num ; i++){
  *      int cost = costs[i] ;
  *      for(int j = money ; j >= cost ; j--){
  *        dp[j] = Math.max(dp[j] , dp[j - cost]);
  *      }
  *     }
  *     return dp[money];
  *    <img width="899" height="268" alt="image" src="https://github.com/user-attachments/assets/e170427f-6966-4069-ae7a-ae3892e59d99" />
  *
  *    
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 数量记作si (i = 1 , …… , n) 
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 三重循环  ***************************************/
  * 实际上是看作是存在 $\sum_{i=1}^{n} s_i$ 种物品 做上面的0-1背包问题
  *     for(int i = 1 ; i < num ; i++){
  *       int s = nums[i] , cost = costs[i] , value = values[i];
  *       for(int j = 1 ; j <= money ; j++){
  *        for(int k = 1 ; k <= s && k * cost <= j ; k++){
  *           dp[i][j] = Math.max(dp[i - 1][j] , dp[i - 1][j - k * cost] + value * k);
  *        }
  *      }
  *     }
  *     return dp[num][moeny];
  *   
  *
  *************************************** 二进制优化 **************************************/
  *   
  * 
  *
  *
  *
  *
  *
  *
  *
  *
  *
  *
  *
  
