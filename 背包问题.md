  /** 标准的0-1背包问题
  *    容量大小为m的背包  存在n种物品 物品的重量记作wi 价值记作vi (i = 1 , …… , n) 每种物品数量都是1
  *    求背包中可以装入物品的最大价值和是多少？
      
  */

  /************************************** dfs剪枝优化 **************************************/
  *   中心思想 选或不选
  *     int dfs(int index , int money , int[] costs , int[] values , int[][] memo){
          if(index == costs.length) return 0 ;
          if(memo[index][money] == -1){
            int cost = costs[index] , value = values[index];
            if(money >= cost){
              memo[index][money] = Math.max(dfs(index + 1 , money , costs , values , memo) , dfs(index + 1 , meney - cost , values , memo) + value);
            }else memo[index][money] = dfs(index + 1 , money , costs , values , memo);
          }
        return memo[index][money];
        }    
                   
  *************************************** 递归 -> 递推 **************************************/
  * // 二维数组 dp[num + 1][money + 1];
  *     for(int i = 1 ; i < num ; i++){
         int cost = costs[i];
         for(int j = 1 ; j <= money ; j++){
           dp[i][j] = dp[i - 1][j];
           if(j >= cost){
              int value = values[i];
              dp[i][j] = Math.max(dp[i][j] , dp[i - 1][j - cost] + value);
           }
         }
        }
        return dp[num][moeny];   
  * // 一维滚动数组 dp[i] 只和 dp[i - 1] 相关  每次仅仅改变j 关键是j的变化 倒序遍历
  *     for(int i = 1 ; i < num ; i++){
         int cost = costs[i] ;
         for(int j = money ; j >= cost ; j--){
           dp[j] = Math.max(dp[j] , dp[j - cost]);
         }
        }
        return dp[money];
     <img width="655" height="224" alt="截图20251220113037" src="https://github.com/user-attachments/assets/2e34882f-bc1f-4e91-b10b-73b31e7cf582" />   
   
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(多重背包）
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 数量记作si (i = 1 , …… , n) 
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 三重循环  ***************************************/
  * 实际上是看作是存在 $\sum_{i=1}^{n} s_i$ 种物品 做上面的0-1背包问题
  *      for(int i = 1 ; i < num ; i++){
          int s = nums[i] , cost = costs[i] , value = values[i];
          for(int j = 1 ; j <= money ; j++){
           for(int k = 1 ; k <= s && k * cost <= j ; k++){
              dp[i][j] = Math.max(dp[i - 1][j] , dp[i - 1][j - k * cost] + value * k);
           }
         }
        }
        return dp[num][moeny];
  *************************************** 二进制优化 **************************************/
  *  任何一个数可以由多个二进制数值进行表示 $num=\sum_{i=0}^{n} 2^{n}$
  *  进一步可以构造一个数组用到表示 1 到 num 中的所有数值
  *  比如说10 --> {1 ，2 ， 4 ， 3} , 使用{1 ，2 ， 4 ， 3}可以表示 1 到 10 中的任意一个数值
  *  将同类型的物品进行二进制合并
  *     List<int[]> sum(int cost , int value , int num){
          int n = costs.length;
          List<int[]> ans = new ArrayList();
          for(int i = 0 ; i < n ; i++){
           int count = 0 , curNum = Math.pow(2 , count);
           while(num > curNum){
             int[] temp = new int[2]{ curNum * cost , curNum * value};
             ans.add(temp);
             num -= curNum;
             curNum = Math.pow(2 , ++count);
           }
           if(num != 0)  ans.add(new int[]{num * cost , num * value});      
        return ans;
        }
      
        statci void main(String[] args){
            // Scanner collecitons costs values nums
            Scanner in  = new Scanner(System.in);
            int n = in.nextInt() , money = in.nextInt();
            List<int[]> collections = new ArrayList();
            for(int i = 0 ; i < n ; i++){
              int cost = in.nextInt() , value = in.nextInt() , num = in.nextInt();
              for(int[] arr : sum(cost , value , num)){
                   ans.add(arr)
              }
            }
            int[][] collections = ans.toArray(int[][] :: new);
            n = collections.length;
            int costs = new int[n] , values = new int[n];
            for(int i = 0 ; i < n ; i++){
             int[] cur = collections[i];
             costs[i] = cur[0] , values[i] = cur[1];
            }
            // 进行传统的0-1背包    
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(完全背包)
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 每一种物品都有无数个
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 状态转移  ***************************************/       
  * 将所有物品都看作是一种 即使是种类相同的
  *     dfs(index , money , costs , values , memo){
          if(index == costs.length) return 0;
          if(memo[index][moeny] == -1) {
            int cost = costs[index] , value =  values[index];
            memo[index][moeny] = money >= cost ? Math.max(dfs(index + 1 , money , costs ,values , memo) , dfs(index , money - cost , costs , values , memo) + value) : dfs(index + 1 , money , costs , values , memo);
            // 在资金充足的情况下 可以选择放入该种物品 接着选择下一个 由于每一种物品的种类是无数个 所以这里还是转移到index  或者 直接选取index + 1 中物品
          }
        return memo[idnex][money];
        }
  **************************************** dp数组 **************************************/     
  * 利用0-1背包正序遍历的问题实现完全背包的重复选择 [ACW背包九讲](https://www.acwing.com/problem/content/7/)
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(混合背包)
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 每一种物品的数量{0 ， 1 ， 2 , ……}个
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 混合背包-混合策略  ***************************************/             
  * 首先将多重背包二进制转换为0-1背包 求解0-1背包优化 求解完全背包 [ACW背包九讲](https://www.acwing.com/problem/content/7/) 
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    
 
  /** 带约束的0-1背包问题(物体的价值和费用之间存在函数关系)
  *    容量大小为m的背包  存在n种物品 每种物品的重量未知【若分配给Xi物品k空间，那么Xi物品能提供f(k)的价值】 价值记作vi 每一种物品的数量都是1
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 混合背包-函数约束  ***************************************/    
  * 由于物品的重量未知，那么需要枚举背包分配给物品的空间 [洛谷旅行商的背包](https://www.luogu.com.cn/problem/P1782#ide)
  * 注意：由于每种物品的数量都是1，所以还是0-1背包问题，必须执行倒序遍历
    <img width="625" height="294" alt="image" src="https://github.com/user-attachments/assets/de3a4c9d-2c63-41da-b09a-da945d9c5329" />
  *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    
 
  /** 多重约束的0-1背包问题
  *    容量大小为m，体积大小是v的背包  存在n种物品 每种物品的重量记作wi 体积记作vi 价值记作si
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 多种约束条件 - 多状态转移  ***************************************/    
  * 多种约束条件 但还是针对同一个对象
  *     for(int i = 0 ; i < n ; i++){
            int cost1 = costs1[i] , cost2 = costs2[i] , value = values[i];
            for(int j = money1 ; j >= cost1 ; j--){
                for(int k = money2 ; k >= cost2 ; k--){
                    dp[j][k] = Math.max(dp[j - cost1][k - cost2] + value , dp[j][k]); 
                }
            }
        }
   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    
 
  /** 分组背包
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作si 被分为m组
  *    要求背包中仅可以放入一组物品中的一个，求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 分组约束-状态构造  ***************************************/    
  * 选或不选 dfs中的恢复现场在此时已经显得很复杂   或者说 动态规划的状态转移就不能使用cnt记忆状态并进行恢复的 这是一种结构化的有顺序选择的状态转移的方法 比如说寻路问题
  * 简单来说 dp数组是记录的每一种方案 通过空间换时间 
  *     for(int i = 0 ; i < n ; i++){   

  

  
  
