  /** 标准的0-1背包问题
  *    容量大小为m的背包  存在n种物品 物品的重量记作wi 价值记作vi (i = 1 , …… , n) 每种物品数量都是1
  *    求背包中可以装入物品的最大价值和是多少？
      
  */

  /************************************** dfs剪枝优化 **************************************/
  *   中心思想 选或不选
  *     int dfs(int index , int money , int[] costs , int[] values , int[][] memo){
  *       if(index == costs.length) return 0 ;
  *       if(memo[index][money] == -1){
  *         int cost = costs[index] , value = values[index];
  *         if(money >= cost){
  *           memo[index][money] = Math.max(dfs(index + 1 , money , costs , values , memo) , dfs(index + 1 , meney - cost , values , memo) + value);
  *         }else memo[index][money] = dfs(index + 1 , money , costs , values , memo);
  *       }
  *     return memo[index][money];
  *     }    
  *         
  *                    
  *************************************** 递归 -> 递推 **************************************/
  * // 二维数组 dp[num + 1][money + 1];
  *     for(int i = 1 ; i < num ; i++){
  *      int cost = costs[i];
  *      for(int j = 1 ; j <= money ; j++){
  *        dp[i][j] = dp[i - 1][j];
  *        if(j >= cost){
  *           int value = values[i];
  *           dp[i][j] = Math.max(dp[i][j] , dp[i - 1][j - cost] + value);
  *        }
  *      }
  *     }
  *     return dp[num][moeny];
  *    
  * // 一维滚动数组 dp[i] 只和 dp[i - 1] 相关  每次仅仅改变j 关键是j的变化 倒序遍历
  *     for(int i = 1 ; i < num ; i++){
  *      int cost = costs[i] ;
  *      for(int j = money ; j >= cost ; j--){
  *        dp[j] = Math.max(dp[j] , dp[j - cost]);
  *      }
  *     }
  *     return dp[money];
  *    <img width="899" height="268" alt="image" src="https://github.com/user-attachments/assets/e170427f-6966-4069-ae7a-ae3892e59d99" />
  *
  *    
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(多重背包）
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 数量记作si (i = 1 , …… , n) 
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 三重循环  ***************************************/
  * 实际上是看作是存在 $\sum_{i=1}^{n} s_i$ 种物品 做上面的0-1背包问题
  *     for(int i = 1 ; i < num ; i++){
  *       int s = nums[i] , cost = costs[i] , value = values[i];
  *       for(int j = 1 ; j <= money ; j++){
  *        for(int k = 1 ; k <= s && k * cost <= j ; k++){
  *           dp[i][j] = Math.max(dp[i - 1][j] , dp[i - 1][j - k * cost] + value * k);
  *        }
  *      }
  *     }
  *     return dp[num][moeny];
  *   
  *
  *************************************** 二进制优化 **************************************/
  *  任何一个数可以由多个二进制数值进行表示 $num=\sum_{i=0}^{n} 2^{n}$
  *  进一步可以构造一个数组用到表示 1 到 num 中的所有数值
  *  比如说10 --> {1 ，2 ， 4 ， 3} , 使用{1 ，2 ， 4 ， 3}可以表示 1 到 10 中的任意一个数值
  *  将同类型的物品进行二进制合并
  *     List<int[]> sum(int cost , int value , int num){
  *       int n = costs.length;
  *       List<int[]> ans = new ArrayList();
  *       for(int i = 0 ; i < n ; i++){
  *        int count = 0 , curNum = Math.pow(2 , count);
  *        while(num > curNum){
  *          int[] temp = new int[2]{ curNum * cost , curNum * value};
  *          ans.add(temp);
  *          num -= curNum;
  *          curNum = Math.pow(2 , ++count);
  *        }
  *        if(num != 0)  ans.add(new int[]{num * cost , num * value});      
  *     return ans;
  *     }
  *   
  *     statci void main(String[] args){
  *         // Scanner collecitons costs values nums
  *         Scanner in  = new Scanner(System.in);
  *         int n = in.nextInt() , money = in.nextInt();
  *         List<int[]> collections = new ArrayList();
  *         for(int i = 0 ; i < n ; i++){
  *           int cost = in.nextInt() , value = in.nextInt() , num = in.nextInt();
  *           for(int[] arr : sum(cost , value , num)){
  *                ans.add(arr)
  *           }
  *         }
  *         int[][] collections = ans.toArray(int[][] :: new);
  *         n = collections.length;
  *         int costs = new int[n] , values = new int[n];
  *         for(int i = 0 ; i < n ; i++){
  *          int[] cur = collections[i];
  *          costs[i] = cur[0] , values[i] = cur[1];
  *         }
  *         // 进行传统的0-1背包
  *          
  *           
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(完全背包)
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 每一种物品都有无数个
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 状态转移  ***************************************/       
  * 将所有物品都看作是一种 即使是种类相同的
  *     dfs(index , money , costs , values , memo){
  *       if(index == costs.length) return 0;
  *       if(memo[index][moeny] == -1) {
  *         int cost = costs[index] , value =  values[index];
  *         memo[index][moeny] = money >= cost ? Math.max(dfs(index + 1 , money , costs ,values , memo) , dfs(index , money - cost , costs , values , memo) + value) : dfs(index + 1 , money , costs , values , memo);
  *         // 在资金充足的情况下 可以选择放入该种物品 接着选择下一个 由于每一种物品的种类是无数个 所以这里还是转移到index  或者 直接选取index + 1 中物品
  *       }
  *     return memo[idnex][money];
  *     }
  *         
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(混合背包)
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 每一种物品的数量{0 ， 1 ， 2 , ……}个
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 混合背包-混合策略  ***************************************/             
  * 首先将多重背包二进制转换为0-1背包 求解0-1背包优化 求解完全背包
  * 
  *
  *
  *
  *
  *
  *
  
