  # [背包问题](https://jinloongchen.github.io/post/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html)
  
  /** 标准的0-1背包问题
  *    容量大小为m的背包  存在n种物品 物品的重量记作wi 价值记作vi (i = 1 , …… , n) 每种物品数量都是1
  *    求背包中可以装入物品的最大价值和是多少？
      
  */

  /************************************** dfs剪枝优化 **************************************/
  *   中心思想 选或不选
  *     int dfs(int index , int money , int[] costs , int[] values , int[][] memo){
          if(index == costs.length) return 0 ;
          if(memo[index][money] == -1){
            int cost = costs[index] , value = values[index];
            if(money >= cost){
              memo[index][money] = Math.max(dfs(index + 1 , money , costs , values , memo) , dfs(index + 1 , meney - cost , values , memo) + value);
            }else memo[index][money] = dfs(index + 1 , money , costs , values , memo);
          }
        return memo[index][money];
        }    
                   
  *************************************** 递归 -> 递推 **************************************/
  * // 二维数组 dp[num + 1][money + 1];
  *     for(int i = 1 ; i < num ; i++){
         int cost = costs[i];
         for(int j = 1 ; j <= money ; j++){
           dp[i][j] = dp[i - 1][j];
           if(j >= cost){
              int value = values[i];
              dp[i][j] = Math.max(dp[i][j] , dp[i - 1][j - cost] + value);
           }
         }
        }
        return dp[num][moeny];   
  * // 一维滚动数组 dp[i] 只和 dp[i - 1] 相关  每次仅仅改变j 关键是j的变化 倒序遍历
  *     for(int i = 1 ; i < num ; i++){
         int cost = costs[i] ;
         for(int j = money ; j >= cost ; j--){
           dp[j] = Math.max(dp[j] , dp[j - cost]);
         }
        }
        return dp[money];
     <img width="655" height="224" alt="截图20251220113037" src="https://github.com/user-attachments/assets/2e34882f-bc1f-4e91-b10b-73b31e7cf582" />   
   
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(多重背包）
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 数量记作si (i = 1 , …… , n) 
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 三重循环  ***************************************/
  * 实际上是看作是存在 $\sum_{i=1}^{n} s_i$ 种物品 做上面的0-1背包问题
  *      for(int i = 1 ; i < num ; i++){
          int s = nums[i] , cost = costs[i] , value = values[i];
          for(int j = 1 ; j <= money ; j++){
           for(int k = 1 ; k <= s && k * cost <= j ; k++){
              dp[i][j] = Math.max(dp[i - 1][j] , dp[i - 1][j - k * cost] + value * k);
           }
         }
        }
        return dp[num][moeny];
  *************************************** 二进制优化 **************************************/
  *  任何一个数可以由多个二进制数值进行表示 $num=\sum_{i=0}^{n} 2^{n}$
  *  进一步可以构造一个数组用到表示 1 到 num 中的所有数值
  *  比如说10 --> {1 ，2 ， 4 ， 3} , 使用{1 ，2 ， 4 ， 3}可以表示 1 到 10 中的任意一个数值
  *  将同类型的物品进行二进制合并
  *     List<int[]> sum(int cost , int value , int num){
          int n = costs.length;
          List<int[]> ans = new ArrayList();
          for(int i = 0 ; i < n ; i++){
           int count = 0 , curNum = Math.pow(2 , count);
           while(num > curNum){
             int[] temp = new int[2]{ curNum * cost , curNum * value};
             ans.add(temp);
             num -= curNum;
             curNum = Math.pow(2 , ++count);
           }
           if(num != 0)  ans.add(new int[]{num * cost , num * value});      
        return ans;
        }
      
        statci void main(String[] args){
            // Scanner collecitons costs values nums
            Scanner in  = new Scanner(System.in);
            int n = in.nextInt() , money = in.nextInt();
            List<int[]> collections = new ArrayList();
            for(int i = 0 ; i < n ; i++){
              int cost = in.nextInt() , value = in.nextInt() , num = in.nextInt();
              for(int[] arr : sum(cost , value , num)){
                   ans.add(arr)
              }
            }
            int[][] collections = ans.toArray(int[][] :: new);
            n = collections.length;
            int costs = new int[n] , values = new int[n];
            for(int i = 0 ; i < n ; i++){
             int[] cur = collections[i];
             costs[i] = cur[0] , values[i] = cur[1];
            }
            // 进行传统的0-1背包    
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(完全背包)
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 每一种物品都有无数个
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 状态转移  ***************************************/       
  * 将所有物品都看作是一种 即使是种类相同的
  *     dfs(index , money , costs , values , memo){
          if(index == costs.length) return 0;
          if(memo[index][moeny] == -1) {
            int cost = costs[index] , value =  values[index];
            memo[index][moeny] = money >= cost ? Math.max(dfs(index + 1 , money , costs ,values , memo) , dfs(index , money - cost , costs , values , memo) + value) : dfs(index + 1 , money , costs , values , memo);
            // 在资金充足的情况下 可以选择放入该种物品 接着选择下一个 由于每一种物品的种类是无数个 所以这里还是转移到index  或者 直接选取index + 1 中物品
          }
        return memo[idnex][money];
        }
  **************************************** dp数组 **************************************/     
  * 利用0-1背包正序遍历的问题实现完全背包的重复选择 [ACW背包九讲](https://www.acwing.com/problem/content/7/)
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
 
  /** 带约束的0-1背包问题(混合背包)
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作vi 每一种物品的数量{0 ， 1 ， 2 , ……}个
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 混合背包-混合策略  ***************************************/             
  * 首先将多重背包二进制转换为0-1背包 求解0-1背包优化 求解完全背包 [ACW背包九讲](https://www.acwing.com/problem/content/7/) 
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    
 
  /** 带约束的0-1背包问题(物体的价值和费用之间存在函数关系)
  *    容量大小为m的背包  存在n种物品 每种物品的重量未知【若分配给Xi物品k空间，那么Xi物品能提供f(k)的价值】 价值记作vi 每一种物品的数量都是1
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 混合背包-函数约束  ***************************************/    
  * 由于物品的重量未知，那么需要枚举背包分配给物品的空间 [洛谷旅行商的背包](https://www.luogu.com.cn/problem/P1782#ide)
  * 注意：由于每种物品的数量都是1，所以还是0-1背包问题，必须执行倒序遍历
    <img width="625" height="294" alt="image" src="https://github.com/user-attachments/assets/de3a4c9d-2c63-41da-b09a-da945d9c5329" />
  *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    
 
  /** 多重约束的0-1背包问题
  *    容量大小为m，体积大小是v的背包  存在n种物品 每种物品的重量记作wi 体积记作vi 价值记作si
  *    求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 多种约束条件 - 多状态转移  ***************************************/    
  * 多种约束条件 但还是针对同一个对象
  *     for(int i = 0 ; i < n ; i++){
            int cost1 = costs1[i] , cost2 = costs2[i] , value = values[i];
            for(int j = money1 ; j >= cost1 ; j--){
                for(int k = money2 ; k >= cost2 ; k--){
                    dp[j][k] = Math.max(dp[j - cost1][k - cost2] + value , dp[j][k]); 
                }
            }
        }
   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    
 
  /** 分组背包
  *    容量大小为m的背包  存在n种物品 每种物品的重量记作wi 价值记作si 被分为m组
  *    要求背包中仅可以放入一组物品中的一个，求背包中可以装入物品的最大价值和是多少？
      
  */
  
  /************************************** 分组约束-状态构造  ***************************************/    
  * 选或不选 dfs中的恢复现场在此时已经显得很复杂   或者说 动态规划的状态转移就不能使用cnt记忆状态并进行恢复的 这是一种结构化的有顺序选择的状态转移的方法 比如说寻路问题
  * 简单来说 dp数组是记录的每一种方案 通过空间换时间 和cnt记忆化是两种不同的东西 [leetcode最长递增子序列一维数组&二维网格](https://leetcode.cn/problems/longest-increasing-subsequence/)
  * [ACWING分组背包](https://www.acwing.com/problem/content/description/9/) 注意dfs递归的选或不选 和 dp递推中的for遍历
  *     for(int i = 0 ; i < groupNums ; i++){
           int[][] arr = group.get(i);
           for(int j = moeny ;j >= 0 ; j--){
             for(int k = 0 ; k < arr.length ; k++){
                  int[] cur = arr[k];
                 int cost = cur[0] , value = cur[1];
                 if(j >= cost) dp[j] = Math.max(dp[j] , dp[j - cost] + value);
             }
           }
        }



  /************************************** 方案数（组合数 并非 排列数 即对多重 完全背包仍然适用）  ***************************************/    
  * 背包问题的方案数 重温背包问题中的状态定义 dp[index][money] 表示背包容量是money的情况下 遍历到下标是index物品时候的最大价值 ， 背包可以没被放满 但是dp[last_index][money_full]对应的一定是最大价值 对应方案数也是最大价值下对应的方案数
  * 问题1：存在多少种可以放满这个背包的方案
  * 问题2：存在多少种可以得到最大价值的方案
  * 1：物品的质量和价值在数值上相等
  * 2：物品的质量和价值在数值上不等

  *************************************** 一般的0-1背包的方案数 **************************************/
  * 物品i的耗材costs[i] 价值values[i] 存在多少种可以得到最大价值的方案
  *        int[] profit = new int[money + 1] , ways = new int[money + 1]; // 注意 ： 背包为空 即 最大价值是0对应的方案就是不放物品
           Arrays.fill(ways , 1); // 初始化方案 可以放入第一个物品 和 不放第一个物品 都方案数都是1 即 最大价值是0对应的方案就是不放物品 和 最大价值是第一个物品的价值对应的方案是放入第一个物品
           for(int i = 0 ;i < nums ; i++){
             int cost = costs[nums] , value = values[nums];
             for(int j = money ; j >= cost; j--){
               int valueF = profit[j] , valueC = profit[j - cost] + value;
               if(valueF < valueC){
                   profit = valueC;
                   ways[j] = ways[j - cost];
               }else if(valueF == valueC){
                   ways[j] = ways[j - cost] + ways[j];
               }
             }
           }
           return ways[money];

 * 物品i的耗材costs[i] 价值values[i] 并且 costs[i] == values[i] 此时dp[last_index][money_full]对应的一定是最大价值 也是 放入物品的最大质量
 * 若背包容量等于最大物品的价值 那么 存在多少种可以得到最大价值的方案 等价于 存在多少种可以放满这个背包的方案 因为最大价值就是背包容量 并且 至少存在一种方案使得在该方案下放入背包中的物品总价值最大（直接放入最大物品）
 * 启发：在条件1成立下，只要判断dp[last_index][money_full] == money_full ? dp[last_index][money_full] : 0 ; 即可
 * [幂次和方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/description/)
 *      public int numberOfWays(int n, int x) {
            int[] ways = new int[n + 1] , profit = new int[n + 1];
            Arrays.fill(ways , 1);
            // 保证最大的容量的时候 放入的物品的最大价值就是背包容量
            // 倒序遍历 0-1背包  物品的容量和价值对等
            boolean choose = false;
            for(int i = 1 ; Math.pow(i , x) <= n ; i++){
                int leastCost = (int)Math.pow(i , x);
                for(int j = n ; j >=  leastCost ; j--){
                    int valuef = profit[j] , valueC = profit[j - leastCost] + leastCost;
                    if(valueC == valuef) ways[j] = (ways[j - leastCost] + ways[j]) % mod;
                    else if(valueC > valuef) {
                        ways[j] = ways[j - leastCost];
                        profit[j] = valueC;
                        
                    }
                }
            }
           
            return profit[n] == n ? ways[n] : 0;
        }

  /************************************ 转换状态的定义 **************************************************/
  * 定义dp[i]表示装满i容量的方案数 dp[i]可以是0 必须是装满该容量的时候才可以进行计数
  * 重写幂次和方案数：
  *           public int numberOfWays(int n  , int x){
                int[] memo = new int[n + 1];
                memo[0] = 1;
                for(int i = 1 ; Math.pow(i , x) <= n ; i++){
                  for(int j = (int)Math.pow(i , x) ; j <= n ; j++）{ // 注意可重复选 和 不可重复选
                    memo[j] += memo[j - Math.pow(i , x)];
                  }
                }
                return memo[n];
    
               
 /**
 *  重点：物品的价值等于物品的质量 并且 已知所有的能放入背包中的物品组合中 最大价值 数值上等于 背包的最大容量 
 *   此时：两个问题等价 

   
 */
 /************************************ 目标和 **************************************************/
 *         public int targetSum(int[] nums , int target){
             int sum = 0;
             for(int i : nums) { sum += nums[i];}
             int targetNew = target + sum;
             if(target + sum < 0 || targetNew % 2 != 0) return 0;
             targetNew /= 2;
             int[] dp = new int[targetNew + 1];
             dp[0] = 1;
             for(int i : nums){
               for(int j = targetNew ; j >= i ; j--){
                 dp[j] += dp[j - targetNew];
               }
             }
             return dp[targetNew];
           }


 /************************************ 完全平方数 零钱兑换 **************************************************/
 * 0-1 or 完全背包中所有方案数种最小的物品数量  (物品的消耗和价值在数值上相等）
 *        int num = coins.length;
          int[] dp = new int[amount + 1];
          Arrays.fill(dp , Integer.MAX_VALUE);
          dp[0] = 0;
          for(int i = 1 ; i <= num ; i++){
              int cost = coins[i - 1];
              for(int j = cost ; j <= amount ; j++){
                  dp[j] = Math.min(dp[j] , dp[j - cost] + 1);
              }
          }
  
          return dp[amount] == 0 ? -1 : dp[amount];

  /********************************** 组合数衍生到子集选择问题 ***************************************/
  * 经典的将集合划分为两个元素和相等的两个互斥的子集 [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)
  * 

  * 
  *************************************** 一般的0-1背包的具体方案收集 **************************************/
  * 由于0-1背包的方案数巨大 从上面求可能的方案数就可以看出 故仅要求输出一个可能的方案 通常和字典序有关
  * 一维滚动数组所蕴含的信息不足 需要二维数组进行记录全局信息 输出顺序 和 物品的遍历顺序相关
  * 按照符合条件的最小字典序的方案  逆序遍历 正序回溯[0-1背包具体方案](https://www.acwing.com/file_system/file/content/whole/index/content/3563/)
  *         int[][] dp = new int[num + 2][money + 1];
            for(int i = num ; i >= 1 ; i--){
              int cost = costs[i - 1] , value = values[i - 1];
              for(int j = money ; j >= 0 ; j--){
                dp[i][j] = dp[i + 1][j];
                if(j >= cost) dp[i][j] = Math.max(dp[i][j] , dp[i + 1][j - cost] + value);
              }
            }
            // 回溯寻找对应的方案 字典序最小
            for(int i = 1 ; i <= num ; i++){
              int cost = cost[i - 1] , value = values[i - 1];
              if(money >= cost && dp[i][money] = dp[i + 1][money - cost] + value){
                System.out.println(i);
                money -= cost;
              }
            }
              
   *************************************** 完全背包的具体方案收集 **************************************/
   * 单开一个二维数组进行记录每一个物品的选择次数 按照字典序大小进行方案的输出 判定条件： if(dp[j - costs[i - 1]] + values[i - 1] >= dp[j]) {在使用0 到 i-1个物品的组合可以达到和使用0到i个物品组合的最大价值时 我们选择后者 也就是更新选择当前的物品}
   *      int[] dp = new int[money + 1];
          int[][] cnt = new int[num + 1][money + 1];
          for(int i = 1; i <= num; i++){
              for(int j = costs[i - 1] ; j <= money ; j++){
                  if(dp[j - costs[i - 1]] + values[i - 1] > dp[j]){
                      dp[j] = dp[j - costs[i - 1]] + values[i - 1];
                      cnt[i][j] = cnt[i][j - costs[i - 1]] + 1; // 注意是记录选择了第i个物品多少次
  
                  }
              }
          }
  
          // 回溯
          for(int i = num; i >= 1; i--){
              while(cnt[i][money] > 0){
                  System.out.println(i + " ");
                  money -= costs[i - 1];
              }
          }
  
   
   ************************************** 进一步选择最大价值对应的所有方案数中物品数量最小的方案的具体选择 ********************************************/
   *    将物品按照物品的质量进行降序排列或者升序排列 对应的进行回溯选择 得到的就是数量最小和数量最多的方案
   *    注意：Array.sort(<非基本类>[],compareTor<>())


   # 收集背包中达到最大价值的所有存放物品的方法 回溯（方案：元素是否可重复[集合是否固定 dfs中for循环的index是否重0开始] 子集型[按元素区分] 全/排列型[按顺序区分] 有约束的组合型[固定子集/排列的大小])
   ************************************** 回溯  ********************************************/

   # 区间dp 
   ************************************** 可以从数组的中间开始操作 操作后两个区间的独立性（反向）[戳气球]  ********************************************/
   # 状态dp 枚举选哪个的另一个版本 dfs记录上一个状态 显式的状态转移 
   ************************************** 买卖股票 ********************************************/
   ************************************** 状态dp中的另类 乘积最大的子数组 ********************************************/
