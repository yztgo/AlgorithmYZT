# 树
/** 树的表示
    链表表示法 图邻接表表示法
*/
/************************************** 链表表示法 **************************************/‘ 
*     class TreeNode{
         var num;
         TreeNode left;
         TreeNode right;
         List<TreeNode> childrens;
     }

*************************************** 邻接表表示法 **************************************/
*      List<Integer>[] trees = new List[num];
       Arrays.setAll(trees , _ -> new ArrayList());
       for(int i = 0 ; i < num ; i++) trees[parent[i]].add(i);
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *      
  
/** 二叉树的分类及其性质
|二叉树| 搜索二叉树  | 平衡二叉树 | 线段树  | 平衡二叉树 | 
| :-------------: | :-------------: | ------------- | ------------- | ------------- |
| 任意两个点之间有一条路径 | 右节点(null) > 父节点 > 左子点(null)  | Content Cell  | ------------- | ------------- |
|最小生成树 验证平衡二叉树 直径 路径总和(有方向/无方向) 翻转 合并 遍历 还原  | 构建 验证 寻找  | Content Cell  | ------------- | ------------- |
      
*/
/************************************** dfs剪枝优化 **************************************/
 *   中心思想 选或不选
 *     int dfs(int index , int money , int[] costs , int[] values , int[][] memo){
          if(index == costs.length) return 0 ;
          if(memo[index][money] == -1){
            int cost = costs[index] , value = values[index];
            if(money >= cost){
              memo[index][money] = Math.max(dfs(index + 1 , money , costs , values , memo) , dfs(index + 1 , meney - cost , values , memo) + value);
            }else memo[index][money] = dfs(index + 1 , money , costs , values , memo);
          }
        return memo[index][money];
        }    
                   
*************************************** 递归 -> 递推 **************************************/
* // 二维数组 dp[num + 1][money + 1];
*     for(int i = 1 ; i < num ; i++){
         int cost = costs[i];
         for(int j = 1 ; j <= money ; j++){
           dp[i][j] = dp[i - 1][j];
           if(j >= cost){
              int value = values[i];
              dp[i][j] = Math.max(dp[i][j] , dp[i - 1][j - cost] + value);
           }
         }
        }
        return dp[num][moeny];   
   
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
