# 树
/** 树的表示
    链表表示法 图邻接表表示法
*/
/************************************** 链表表示法 **************************************/‘ 
*     class TreeNode{
         var num;
         TreeNode left;
         TreeNode right;
         List<TreeNode> childrens;
     }

*************************************** 邻接表表示法 **************************************/
*      List<Integer>[] trees = new List[num];
       Arrays.setAll(trees , _ -> new ArrayList());
       for(int i = 0 ; i < num ; i++) trees[parent[i]].add(i);
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *      
  
/** 标准的0-1背包问题
*    容量大小为m的背包  存在n种物品 物品的重量记作wi 价值记作vi (i = 1 , …… , n) 每种物品数量都是1
*    求背包中可以装入物品的最大价值和是多少？
      
*/
/************************************** dfs剪枝优化 **************************************/
 *   中心思想 选或不选
 *     int dfs(int index , int money , int[] costs , int[] values , int[][] memo){
          if(index == costs.length) return 0 ;
          if(memo[index][money] == -1){
            int cost = costs[index] , value = values[index];
            if(money >= cost){
              memo[index][money] = Math.max(dfs(index + 1 , money , costs , values , memo) , dfs(index + 1 , meney - cost , values , memo) + value);
            }else memo[index][money] = dfs(index + 1 , money , costs , values , memo);
          }
        return memo[index][money];
        }    
                   
*************************************** 递归 -> 递推 **************************************/
* // 二维数组 dp[num + 1][money + 1];
*     for(int i = 1 ; i < num ; i++){
         int cost = costs[i];
         for(int j = 1 ; j <= money ; j++){
           dp[i][j] = dp[i - 1][j];
           if(j >= cost){
              int value = values[i];
              dp[i][j] = Math.max(dp[i][j] , dp[i - 1][j - cost] + value);
           }
         }
        }
        return dp[num][moeny];   
   
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   
