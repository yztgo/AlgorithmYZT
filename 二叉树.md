# 树
/** 树的表示
    链表表示法 图邻接表表示法
*/
/************************************** 链表表示法 **************************************/‘ 
*     class TreeNode{
         var num;
         TreeNode left;
         TreeNode right;
         List<TreeNode> childrens;
     }

*************************************** 邻接表表示法 **************************************/
*      List<Integer>[] trees = new List[num];
       Arrays.setAll(trees , _ -> new ArrayList());
       for(int i = 0 ; i < num ; i++) trees[parent[i]].add(i);
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *      
  
/** 二叉树的分类及其性质
|二叉树| 搜索二叉树  | 平衡二叉树 | 线段树  | 平衡二叉树 | 
| :-------------: | :-------------: | ------------- | ------------- | ------------- |
| 任意两个点之间有一条路径 | 右节点(null) > 父节点 > 左子点(null)  | Content Cell  | ------------- | ------------- |
| 最小生成树 验证对称/搜索/平衡二叉树 直径 路径总和(有方向/无方向) 最近公共祖先 翻转 两棵树合并 单颗树累加  遍历 推理还原  | 构建 验证 寻找  | Content Cell  | ------------- | ------------- |
      
*/
/************************************** 递归中维护全局变量 **************************************/
 *   使用类成员变量在递归中辅助判断，这类问题通常需要在遍历过程中维护某种状态并基于此做出判断，比如说验证搜索二叉树，树中的路径总和（路径：树中两个节点之间经过的节点序列）
 *   根据问题的不同 递归形式也会存在不同 和二叉树的遍历存在很大的关系
 *   比如说验证二叉搜索树， 由于二叉搜索树的中序遍历得到的是一个递增数组，所以这里可以使用一个全局最小量进行验证 ， 第一次到达叶子节点的时候进行最小量的更新
 *   再说树中的路径总和，这就需要进行后序遍历，得到左边子树的最大值和右边子树的最大值，循环维护当前节点的子树（二叉树-多叉树）中最大值和次大值，通过当前节点连接最大子树和次大子树来更新全局最大值ans , 当前节点连接最大子树得到一个新子树向上传递
 *   最后说前序遍历，在当前节点循环判断选择子树，[相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/description/)
 *   
                   
*************************************** 二叉树中的返回对象 **************************************/
* 递归中的返回对象是递归的第一要义
* [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/) 返回的真是一个对象 
*     Tree dfs(TreeNode root , TreeNode left , TreeNode right){
         if(root == null || root == left || root == right) return root;
         TreeNode leftNode = dfs(root.left , left , right) , rightNode = dfs(root.rigth , left , right);
         if(leftNode == null) return right; //左边没找到 ， 看在右边是否找到
         if(rightNode == null) return left; //右边没找到 ， 看在左边是否找到
         return root;   // 两边都找到了 说明当前节点就是根节点

*[二叉树的最大搜索二叉树之和](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/description/)
*      int[] dfs(TreeNode root){
              if(root == null) return new int[]{Integer.MAX_VALUE , Integer.MIN_VALUE , 0};
              int[] left = dfs(root.left) , right = dfs(root.right);
              int cur = root.val;
              if(left[1] < cur && right[0] > cur) ans = Math.max(ans , cur + left[2] + right[2]);
              else return new int[]{Integer.MIN_VALUE , Integer.MAX_VLAUE , 0};
              return new int[]{Math.min(left[0] , cur) , Math.max(right[1] , cur) , cur + left[2] + right[2]};
        }

*[根据后序遍历和中序遍历还原二叉树](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/description/)
*     TreeNode buildTree(int[] inorder , int[] postorder){
           int len = inorder.length;
           if(len == 0) return null;
           int index = find(postorder[len - 1] , inorder);// 找到左右子树的切分点
           int[] leftInorder = Arrays.copyOfRange(inorder , 0 , index) , rightInorder = Arrays.copyOfRange(inorder , index + 1 , len) , leftPostorder = Arrays.copyOfRange(postorder , 0 , index) , rightPostorder(postorder , index , len - 1);
           return new TreeNode(inorder[index] , buildTree(leftInorder , leftPostorder) , buildTree(rightInorder , rightPostorder));
   
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   

## 树-无环图
/** 树可以看作是一种n个节点存在n-1条边的无向无环图
    多颗树（集合）
*/ 
                   
/*************************************** 并查集 **************************************/











/*************************************** 无向图中的单向dfs ****************************/
* 给你一个表示n个城市之间连接关系的邻接矩阵，请你找出这些城市可以被分为几类。
*     for(int i =  0 ; i < n ; i++){
         if(cnt[i] == 0) {
             temp = new ArrayList();
             dfs(i);
             ans.add(temp);
         }
      }
*     dfs(int index){
          cnt[index] = 1;
          temp.add(i);
          for(int i = index + 1 ; i < n ; i++){
              if(cnt[i] != 1){
                  dfs(i);
              }
          }
      }
  
