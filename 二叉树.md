# 树
/** 树的表示
    链表表示法 图邻接表表示法
*/
/************************************** 链表表示法 **************************************/‘ 
*     class TreeNode{
         var num;
         TreeNode left;
         TreeNode right;
         List<TreeNode> childrens;
     }

*************************************** 邻接表表示法 **************************************/
*      List<Integer>[] trees = new List[num];
       Arrays.setAll(trees , _ -> new ArrayList());
       for(int i = 0 ; i < num ; i++) trees[parent[i]].add(i);
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *      
  
/** 二叉树的分类及其性质
|二叉树| 搜索二叉树  | 平衡二叉树 | 线段树  | 平衡二叉树 | 
| :-------------: | :-------------: | ------------- | ------------- | ------------- |
| 任意两个点之间有一条路径 | 右节点(null) > 父节点 > 左子点(null)  | Content Cell  | ------------- | ------------- |
| 最小生成树 验证对称/搜索/平衡二叉树 直径 路径总和(有方向/无方向) 最近公共祖先 翻转 两棵树合并 单颗树累加  遍历 推理还原  | 构建 验证 寻找  | Content Cell  | ------------- | ------------- |
      
*/
/************************************** 递归中维护全局变量 **************************************/
 *   使用类成员变量在递归中辅助判断，这类问题通常需要在遍历过程中维护某种状态并基于此做出判断，比如说验证搜索二叉树，树中的路径总和（路径：树中两个节点之间经过的节点序列）
 *   根据问题的不同 递归形式也会存在不同 和二叉树的遍历存在很大的关系
 *   比如说验证二叉搜索树， 由于二叉搜索树的中序遍历得到的是一个递增数组，所以这里可以使用一个全局最小量进行验证 ， 第一次到达叶子节点的时候进行最小量的更新
 *   再说树中的路径总和，这就需要进行后序遍历，得到左边子树的最大值和右边子树的最大值，循环维护当前节点的子树（二叉树-多叉树）中最大值和次大值，通过当前节点连接最大子树和次大子树来更新全局最大值ans , 当前节点连接最大子树得到一个新子树向上传递
 *   最后说前序遍历，在当前节点循环判断选择子树，[相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/description/)
 *   
                   
*************************************** 二叉树中的返回对象 **************************************/
* 递归中的返回对象是递归的第一要义
* [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/) 返回的真是一个对象 
*     Tree dfs(TreeNode root , TreeNode left , TreeNode right){
         if(root == null || root == left || root == right) return root;
         TreeNode leftNode = dfs(root.left , left , right) , rightNode = dfs(root.rigth , left , right);
         if(leftNode == null) return right; //左边没找到 ， 看在右边是否找到
         if(rightNode == null) return left; //右边没找到 ， 看在左边是否找到
         return root;   // 两边都找到了 说明当前节点就是根节点

*[二叉树的最大搜索二叉树之和](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/description/)
*      int[] dfs(TreeNode root){
              if(root == null) return new int[]{Integer.MAX_VALUE , Integer.MIN_VALUE , 0};
              int[] left = dfs(root.left) , right = dfs(root.right);
              int cur = root.val;
              if(left[1] < cur && right[0] > cur) ans = Math.max(ans , cur + left[2] + right[2]);
              else return new int[]{Integer.MIN_VALUE , Integer.MAX_VLAUE , 0};
              return new int[]{Math.min(left[0] , cur) , Math.max(right[1] , cur) , cur + left[2] + right[2]};
        }

*[根据后序遍历和中序遍历还原二叉树](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/description/)
*     TreeNode buildTree(int[] inorder , int[] postorder){
           int len = inorder.length;
           if(len == 0) return null;
           int index = find(postorder[len - 1] , inorder);// 找到左右子树的切分点
           int[] leftInorder = Arrays.copyOfRange(inorder , 0 , index) , rightInorder = Arrays.copyOfRange(inorder , index + 1 , len) , leftPostorder = Arrays.copyOfRange(postorder , 0 , index) , rightPostorder(postorder , index , len - 1);
           return new TreeNode(inorder[index] , buildTree(leftInorder , leftPostorder) , buildTree(rightInorder , rightPostorder));
   
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   

## 树-无环图
/** 树可以看作是一种n个节点存在n-1条边的无向无环图
    多颗树（集合）
*/ 
                   
/*************************************** 并查集 **************************************/
初始化 单节点
|0| 1  | 2 | 3  | 4 |  5 | 6  | 7 | 
| :-------------: | :-------------: | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
|0| 1  | 2 | 3  | 4 |  5 | 6  | 7 | 

循环连边 植树造林
edge{1 , 2} edge{3 , 4} edge{1 , 4}
*        union(int node1 , int node2){
            int index1 = find(node1) , index2 = find(node2);
            dp[index2) = index1;
         }
* 查找-路径压缩算法
*         int find(int index){
              if(dp[index] != index){
                  dp[index] = find(dp[index]);
              }
              return dp[index];
          }
* node2 -> node1 (现有的树）
 <img width="124" height="269" alt="image" src="https://github.com/user-attachments/assets/b8147432-3bc3-4e98-ab80-bfd4eaba322b" />
 
|1|2|3|4|
| :-------------: | :-------------: | :-------------: | :-------------: |
|1|1|3|4|
* 对于新连接的节点，若是连接在现有的集合中，已经是最佳的 ， 因为每一次都有路径压缩保证每一个节点和根节点相连 node3 -> node1 or node3 -> node2
<img width="328" height="246" alt="image" src="https://github.com/user-attachments/assets/2ef43772-eae3-407f-a3f2-6122752c69a4" />

|1|2|3|4|
| :-------------: | :-------------: | :-------------: | :-------------: |
|1|1|1|4|
* 但是可能出现新的树， 比如说node3 -> node4 then node3 -> node1
<img width="817" height="389" alt="image" src="https://github.com/user-attachments/assets/d1eaa88b-c47e-4bc4-a9cb-3393dbc6cc2a" />

|1|2|3|4|
| :-------------: | :-------------: | :-------------: | :-------------: |            
|1|1|3|3|

|1|2|3|4|
| :-------------: | :-------------: | :-------------: | :-------------: |
|1|1|1|3|

通过find(i)遍历每个节点实现”归一化“
|1|2|3|4|
| :-------------: | :-------------: | :-------------: | :-------------: |
|1|1|1|1|
<img width="841" height="595" alt="image" src="https://github.com/user-attachments/assets/27095cae-ce00-42f7-b97a-bbb58c6f0682" />

# 原理：将小集合依附于不小于它的集合
/*************************************** 判断图是否是一个无环图 *****************************/
* 二维数组edges : int[n][2] 表示存在n条无向边 由于n个节点组成的无环图只存在n-1条边 所以请你剔除其中的一条边使得剩余的n-1条边能够组成无环图
* 条件1：若edge[i][0] < edge[i][1] 则直接使用并查集（edge[i][1] 指向 edge[i][0])进行判断即可 找出其中第一个成环的进行提出即可 （原理）
* 条件2：实际上上述无环图可以看作是一颗树，判断树中成环的依据就是某一个节点的入度等于2（在叶子节点连接某一个节点的时候就不会出现出度等于2的情况） 
* [冗余连接I](https://leetcode.cn/problems/redundant-connection/description/) 每一条边都是无向边，但是要求edge[i][0] < edge[i][1] 符合条件1
* [冗余连接II](https://leetcode.cn/problems/redundant-connection-ii/description/)每一条边都是有向边，严格按照树的定义组织图，edge[i][0] 指向 edge[i][1] 符合条件2 , 题目要求的测试数据中，图中至多只有一个存在两个父节点的节点 , 并且不会出现存在两个以上父节点的节点
<img width="931" height="185" alt="image" src="https://github.com/user-attachments/assets/143c3a72-7864-4268-bf77-7510f75954cb" />




/************************************** 以二叉树形式连接边构造图 ***************************/
* leftChild : int[n] rightChild : int[n]图中存在n个节点 第i个节点存在两个子节点构成两条可能的边（node 可能为 -1） leftChild[i] , rightChild[i]
* 判断[验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/description/)
* 1：是否构成一个无环图
* 2：是否构成一棵树
* 是否有指向性（有向边）
<img width="310" height="222" alt="image" src="https://github.com/user-attachments/assets/81f027c1-d450-4002-b245-abd499441aad" />

* 树的一个特性：每一个节点的入度为1，上述情况无法满足。
*      boolean[] cnt ;
       int[] dp ;
       boolean solution(int n , int[] leftChild , int[] rightChild){
            this.cnt = new int[n];
            this.dp = new int[n];
            for(int i = 0 ; i < n ; i++){
               dp[i] = i;
            }
       for(int i = 0 ; i < n ; i++){
           if(leftChild[i] == rightChild[i] && leftChild[i] == -1) continue;
           int index1 = find(i) , index2 = find(leftChild[i]) , index3 = find(rightChild[i]) ;
           if(index1 == index2 || index1 == index3 || index2 == index3) return false;
           if(index2 != -1){
               if(cnt[leftChild[i]]) return false;
               dp[index2] = index1;
               cnt[cnt[leftChild[i]] = true;
           }
           if(index3 != -1){
               if(cnt[rigthChild[i]]) return false;
               dp[index3] = index1;
               cnt[rightChild[i]] = true;
           }
       }
       for(int i = 0 ; i < n ; i++) {
           find(i);
           if(i == 0) continue;
           if(dp[i] != dp[0]) return false;
       }

       return true;
       




/*************************************** 无向图中的单向dfs ***************************/
* 给你一个表示n个城市之间连接关系的邻接矩阵，请你找出这些城市可以被分为几类。
* 虽然可以使用并查集（上面的规则1 edge[i] -> edge[j] （j > i) 注意最后使用循环find(i)遍历 使得每一个连通块中的节点都指向根节点
   
  <img width="1053" height="148" alt="image" src="https://github.com/user-attachments/assets/bbad95d2-63e6-4e66-9fc4-6defd9389d6a" />

*     for(int i =  0 ; i < n ; i++){
         if(cnt[i] == 0) {
             temp = new ArrayList();
             dfs(i);
             ans.add(temp);
         }
      }
*     dfs(int index){
          cnt[index] = 1;
          temp.add(i);
          for(int i = index + 1 ; i < n ; i++){
              if(cnt[i] != 1){
                  dfs(i);
              }
          }
      }
  
