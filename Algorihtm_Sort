# 关于十大经典排序算法的一个说明

1：排序算法的特点
  时间复杂度 耗时
  空间复杂度 是否是原地排序 是否需要创建新的存放空间
  稳定排序   多指标排序 按照指标1排好序之后 按照指标2排序不会影响指标1中的相对位置 （原始数据集中数据的相对位置不会因为按照某一个指标排序而发生改变）
    example: [ person["Tom" , 12] , person["Jerry" , 12] , person["Nike" , 20] ]
            对上述列表List<Person> 按照person对象的年龄进行排序 ，排序后的结果应该是
             [ person["Nike" , 20] , person["Tom" , 12] , person["Jerry" , 12] ]
            即 Tom 和 Jerry 的相对位置不应该发生变换

2：排序算法的具体说明
  2.1：选择排序 
      原理：每次选择数组中最小的元素 找到对应的下标 将其挪到对应的位置 每一轮将第i小的元素放入对应的第i个位置(互换)
      int temp , sortedIndex = 0 ， movingIndex;
      while(sortedIndex < n - 1){
            temp = nums[sortedIndex];
            movingIndex = sortedIndex;
            for(int i = sortedIndex + 1 ; i < n ; i++){
              movingIndex = nums[movingInedx] < nums[i] ? movingIndex : i;
            }
      nums[sortedIndex] = nums[movingIndex];
      nums[movingIndex] = nums[sortedIndex]
      sortedIndex++;
      }

      特点：非稳定排序 牺牲空间 达到稳定排序的效果
      心得：这种原地排序index很重要

  2.2：冒泡排序 
      原理：交换相邻两个元素的位置 始终将最大的元素置后 每一轮是将第i大的元素放到最后第i个位置
      int temp , sortedIndex = n - 1;
      while(sortedIndex > 0){
            for(int i = 0 ; i < sortedIndex ; i++){
              if(nums[i] > nums[i + 1]){
                temp = nums[i + 1];
                nums[i + 1] = nums[i];
                nums[i] = temp;
              }
      sortedIndex--;
      }

      特点：稳定排序 只有在后面元素小于前面元素的情况下 才会进行元素交换
      心得：如何快速的想好双重for循环 从里面的for循环入手 起始点 终止点 一般总会有一个是固定的（固定的通常和数据本身有关） 一个和外层循环相关联 是动态的
            内层for循环是一轮的操作 比如这里是想将“数组”中最大的数值移动到最后 数组是动态的 长度缩小

      优化选择排序，提高其稳定性，牺牲时间复杂度的冒泡算法
      原理：选择排序中是找到右边未排序的数组中最小的数值 ，将其和当前位置进行交换 ， 也就是nums[sortedIndex , ···]中的最小值 和 nums[sortedIndex] 进行交换
            现在的做法是将sortedIndex , ··· , minValIndex - 1 对应的数组 整体后移一位 保证其稳定性
      int temp , movingIndex , sortedIndex = 0 ;
      while(sortedIndex < n - 1){
            movingIndex = sortedIndex;
            for(int i = sortedIndex + 1 , i < n ; i++){
                movingIndex = nums[movingIndex] < nums[i] ? movingIndex : i;
            }
            temp = nums[movingIndex];
            //找到未排序数组中的最小值
            心得：在数组中找到你想要的数值，通过下标记录比直接记录数值带来的便利性更大
          
            for(int i = movingIndex ; i > sortedIndex ; i--){
                nums[i] = num[i - 1];
            }

            nums[sortedIndex] = temp;
            // 交换最小值到对应的位置
          sortedIndex++;
      }


    2.3：插入排序
        原理：打扑克原理，数组的左边表示左手，数组的右边表示待拿取的牌；左手是按照从小到大排列好的，右手拿到的是新的牌，从左手最大的牌开始和右手拿到的牌进行比较，然后判断是否进行交换
        int temp , movingIndex , sortedIndex = 0;
        while(sortedIndex < n - 1){
              temp = nums[sortedIndex + 1];
              for(int i = sortedIndex ; i > -1 ; i--){
                if(nums[i] < temp){
                  movingIndex = i; // 数值变换 数值加减 地址转换 三种操作在计算机中的耗时
                  nums[i + 1] = nums[i];
                }
                else{
                  nums[movingIndex] = temp;
                  break;
                }
              }
        }

        特点：将新的牌插入已经排好序的牌中，如果新的牌比排好序的最后一张牌还要大，则不需要排序，复杂度降低o(N)，最坏的情况下是冒泡排序的时间复杂度，相当于冒泡排序子问题的逆

