# 高效计算 
/** 一些简便计算的技巧 涉及到位运算等等 */

******************************** （矩阵/数）快速幂 ****************************************/
* while自平方幂x => $x^2$ ; 幂次N符号左移相与一 N >>= 1 & 1 => record  是否相乘取绝record ans *= record == 1 ? x : 1;

<img width="696" height="743" alt="image" src="https://github.com/user-attachments/assets/fc4166f5-4d8b-4bf3-883c-5dd0e4244e16" />

int的取值范围在[-$`2^{31}`$ , $`2^{31}`$ - 1] , 注意在取相反数的时候可能产生的溢出问题 所以统一为long
*      int ans = 1;
       long N = n; // 
       if(n < 0) N *= -1;
       while(N != 0){
         ans *= ((N >> = 1) & 1) == 1 ? x : 1'
         x *= x;
       }
       return ans;

******************************** 计算两个数的最大公约数gcd / 最小公倍数lcm ****************************************/
* gcd 欧几里得算法 时间复杂度控制在O(N) 在数值较大的时候无法高效计算 辗转相除法
*         whlie(b != 0){
                int temp = b;
                b = a % b;
                a = temp;
         }
         return a;
* stein算法 时间复杂度控制在O(logN) 优化后的根相相减法
*       steinGcd(int a , int b){
                if(a % 2 == 0 && b % 2 == 0） gcd(a , b) = gcd(a >> 2 , b >> 2) << 2;
                if(a % 2 == 0 && b % 2 == 1)  gcd(a , b) = gcd(a >> 2 , b);
                if(a % 2 == 1 && b % 2 == 1 && a > b) gcd(a , b) = gcd(a - b , b);
* gcd(a , b) * lcm(a , b) = a * b

******************************** 计算多个数的最大公约数 ****************************************/
* 计算int[] nums中所有数的最大公约数
* gcd(int num : nums) = gcd(gcd(nums[0] , nums[1]) , nums[2] , …… , nums[n -1])
* lcm(int num : nums) = lcm(lcm(nums[0] , nums[1]) , nums[2] , …… , nums[n -1])

******************************** 搜集某个数的所有因数 ****************************************/
* 搜集一组数int[] nums 中每一个数num : nums 中的所有因数
*       int mx = 100_001;
        List<Integer>[] collectors = new ArrayList[mx];
        boolean initial;
        void initials(){
           if(!initial){
                  initial = true;
                  for(int i = 1 ; i < mx ; i++){ // 表示因子
                         for(int j = i ; j < mx ; j += i){ // 表示i是哪些数的因子
                                collectors[j].add(i);
                         }
                  }
           }
      }

******************************** 欧拉筛质数 ***************************************************/
* 用于搜集所有小于某一个数的所有质数
*        boolean[] primes = new boolean[n];
         Arrays.fill(primes , true);
         for(int i = 2 ; i < n ; i++){
            if(!prime[i]) continue;
            for(int j = i * i ; j < n ; j += i){
                   prime[i] = false;
            }

******************************** 2 3 5 丑数 ***************************************************/
* 基坐标 认定1是丑数 所有的丑数都是2 3 5的若干个乘积 从大到小列举出所有的丑数
*        int[] auglys = new int[mx];
         augly[0] = 1;
         int index1 = 0 , index2 = 0 , index3 = 0;
         for(int i = 1 ; i < mx ; i++){
            int a = auglys[index1] * 2 , b = auglys[index2] * 3 , c = auglys[index3] * 5;
            auglys[i] = Math.min(Math.min(a , b) , c);
            if(a == auglys[i]) index1++;
            if(b == auglys[i]) index2++;
            if(c == auglys[i]) index3++;
         }
                   
  
