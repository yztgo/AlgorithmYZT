# 高效计算 
/** 一些简便计算的技巧 涉及到位运算等等 */

******************************** （矩阵/数）快速幂 ****************************************/
* while自平方幂x => $x^2$ ; 幂次N符号左移相与一 N >>= 1 & 1 => record  是否相乘取绝record ans *= record == 1 ? x : 1;

<img width="696" height="743" alt="image" src="https://github.com/user-attachments/assets/fc4166f5-4d8b-4bf3-883c-5dd0e4244e16" />

int的取值范围在[-$`2^{31}`$ , $`2^{31}`$ - 1] , 注意在取相反数的时候可能产生的溢出问题 所以统一为long
*      int ans = 1;
       long N = n; // 
       if(n < 0) N *= -1;
       while(N != 0){
         ans *= ((N >> = 1) & 1) == 1 ? x : 1'
         x *= x;
       }
       return ans;

******************************** 计算两个数的最大公约数gcd / 最小公倍数lcm ****************************************/
* gcd 欧几里得算法 时间复杂度控制在O(N) 在数值较大的时候无法高效计算 辗转相除法
*         whlie(b != 0){
                int temp = b;
                b = a % b;
                a = temp;
         }
         return a;
* stein算法 时间复杂度控制在O(logN) 优化后的根相相减法
*       steinGcd(int a , int b){
                if(a % 2 == 0 && b % 2 == 0） gcd(a , b) = gcd(a >> 2 , b >> 2) << 2;
                if(a % 2 == 0 && b % 2 == 1)  gcd(a , b) = gcd(a >> 2 , b);
                if(a % 2 == 1 && b % 2 == 1 && a > b) gcd(a , b) = gcd(a - b , b);
* gcd(a , b) * lcm(a , b) = a * b

******************************** 计算多个数的最大公约数 ****************************************/
* 计算int[] nums中所有数的最大公约数
* gcd(int num : nums) = gcd(gcd(nums[0] , nums[1]) , nums[2] , …… , nums[n -1])
* lcm(int num : nums) = lcm(lcm(nums[0] , nums[1]) , nums[2] , …… , nums[n -1])
